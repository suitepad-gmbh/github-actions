name: Deploy task definition to AWS ECS

on:
  workflow_call:
    inputs:
      image-uri:
        type: string
        required: true
        description: The URI of the container image to insert into the ECS task definition
      image-tag:
        type: string
        required: true
        description: The container image tag to insert into the ECS task definition
      container-name:
        type: string
        required: false
        description: The name of the container defined in the containerDefinitions section of the ECS task definition
        default: app
      service-name:
        type: string
        required: false
        description: The name of the ECS service to deploy to.
      services:
        type: string
        required: false
        description: 'Json list of services to be deployed. Example: { "include": [{"SERVICE": "rattle"}] }'
      cluster:
        type: string
        required: true
        description: The name of the ECS service's cluster.
      environment:
        type: string
        required: true
        default: staging
        description: The stach environment of the ECS service.
      aws-region:
        type: string
        required: false
        default: eu-central-1
      preview-task-definition:
        type: string
        required: false
        default: 'false'
      skip-migration:
        type: string
        required: false
        default: 'false'
        description: Set true to skip migration run with init task.
      init-task-command:
        type: string
        required: false
        description: Init task command
    
    secrets:
      aws-access-key-id:
        required: true
      aws-secret-access-key:
        required: true

      staging-ecs-template-bucket:
        required: true
        description: The S3 URI of the staging ECS template generated by Terraform.
      production-ecs-template-bucket:
        required: true
        description: The S3 URI of the production ECS template generated by Terraform.

      staging-slack-webhook:
        required: true
      production-slack-webhook:
        required: true

jobs:
  create-deployment:
    runs-on: ubuntu-latest
    name: Create Deployment
    outputs:
      deployment_id: ${{ steps.create-deployment.outputs.deployment_id }}
      target_url: ${{ steps.export-status-url.outputs.url }}
    steps:
      - name: Export service status url
        id: export-status-url
        env:
          DOMAIN: ${{ inputs.environment == 'production' && 'suitepad.systems' || 'suitepad.engineering' }}
        run: |
          echo "::set-output name=url::https://${{ inputs.service-name }}.${{ inputs.environment }}.${{ env.DOMAIN }}/status"

      - uses: chrnorm/deployment-action@master
        name: Create deployment
        id: create-deployment
        with:
          ref: ${{ inputs.image-tag }}
          token: ${{ github.token }}
          environment: ${{ inputs.environment }}
          target_url: ${{ steps.export-status-url.outputs.url }}
          description: "[${{ inputs.service-name }}-${{ inputs.environment }}]"
          initial_status: in_progress 

  run-init-task:
    name: Run migrations first
    runs-on: ubuntu-latest
    needs: [create-deployment]
    steps:
      - name: Export short image tag to outputs
        id: shorten-image-tag
        run: |
          image_tag=${{ inputs.image-tag }}
          echo "::set-output name=tag::${image_tag:0:7}"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: arn:aws:iam::060918773887:role/ecs-deploy-staging
          role-skip-session-tagging: true
          role-duration-seconds: 3600
          aws-access-key-id: ${{ secrets.aws-access-key-id }}
          aws-secret-access-key: ${{ secrets.aws-secret-access-key }}
          aws-region: ${{ inputs.aws-region }}

      - name: Fetch Task Definition and Network configs
        id: fetch-task-definition
        env:
          TASK_DEFINITION_FILE: ${{ inputs.environment == 'production' && secrets.production-ecs-template-bucket || secrets.staging-ecs-template-bucket }}
        run: |
          aws s3 cp ${{ env.TASK_DEFINITION_FILE }}/${{ inputs.cluster }}-${{ inputs.service-name }}-${{ inputs.environment }} /tmp/task-definition-template.json
          aws s3 cp ${{ env.TASK_DEFINITION_FILE }}/${{ inputs.cluster }}-${{ inputs.service-name }}-${{ inputs.environment }}-network-config /tmp/network-config.json
          NETWORK_CONFIG=$(cat /tmp/network-config.json)
          echo "::set-output name=network-config::${NETWORK_CONFIG//'%'/'%25'}"

      - name: Render ECS task definition
        id: render-app-container
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: /tmp/task-definition-template.json
          container-name: ${{ inputs.container-name }}
          image: ${{ inputs.image-uri }}:${{ steps.shorten-image-tag.outputs.tag }}

      - name: Preview ECS task definition
        if: ${{ inputs.preview-task-definition == 'true' }}
        run: |
          cat ${{ steps.render-app-container.outputs.task-definition }}
      
      - name: Check migration
        id: check-migration
        run: |
          if [ "${{ inputs.skip-migration }}" == "true" ]
          then
            echo "::set-output name=command::"
          else
            echo "::set-output name=command::${{ inputs.init-task-command }}"
          fi


      - name: Deploy to Amazon ECS service
        uses: chiragrajk/amazon-ecs-deploy-task-definition@feature/enable-init-tasks
        with:
          task-definition: ${{ steps.render-app-container.outputs.task-definition }}
          service: ${{ inputs.service-name }}-${{ inputs.environment }}
          cluster: ${{ inputs.cluster }}
          wait-for-service-stability: true
          force-new-deployment: true
          init-task-command: ${{ steps.check-migration.outputs.command }}
          init-task-network-configuration: ${{ steps.fetch-task-definition.outputs.network-config }}

  deploy-task-definition:
    name: Render and deploy task definition
    runs-on: ubuntu-latest
    needs: [run-init-task]
    
    concurrency: deploy-${{ matrix.SERVICE }}
    strategy:
      fail-fast: true
      matrix: ${{ fromJson(inputs.services) }}

    steps:
      - name: Export short image tag to outputs
        id: shorten-image-tag
        run: |
          image_tag=${{ inputs.image-tag }}
          echo "::set-output name=tag::${image_tag:0:7}"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: arn:aws:iam::060918773887:role/ecs-deploy-staging
          role-skip-session-tagging: true
          role-duration-seconds: 3600
          aws-access-key-id: ${{ secrets.aws-access-key-id }}
          aws-secret-access-key: ${{ secrets.aws-secret-access-key }}
          aws-region: ${{ inputs.aws-region }}

      - name: Fetch Task Definition template from S3
        env:
          TASK_DEFINITION_FILE: ${{ inputs.environment == 'production' && secrets.production-ecs-template-bucket || secrets.staging-ecs-template-bucket }}
        run: |
          aws s3 cp ${{ env.TASK_DEFINITION_FILE }}/${{ inputs.cluster }}-${{ matrix.SERVICE }}-${{ inputs.environment }} /tmp/task-definition-template.json

      - name: Render ECS task definition
        id: render-app-container
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: /tmp/task-definition-template.json
          container-name: ${{ inputs.container-name }}
          image: ${{ inputs.image-uri }}:${{ steps.shorten-image-tag.outputs.tag }}

      - name: Preview ECS task definition
        if: ${{ inputs.preview-task-definition == 'true' }}
        run: |
          cat ${{ steps.render-app-container.outputs.task-definition }}

      - name: Deploy to Amazon ECS service
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.render-app-container.outputs.task-definition }}
          service: ${{ matrix.SERVICE }}-${{ inputs.environment }}
          cluster: ${{ inputs.cluster }}
          wait-for-service-stability: true
          force-new-deployment: true

  update-deployment-status:
    runs-on: ubuntu-latest
    name: Update deployment status
    # if: ${{ always() && (needs.deploy.result=='failure') }}
    if: ${{ always() }}
    needs: [create-deployment, deploy-task-definition]
    steps:
      - name: Update deployment status (success)
        uses: chrnorm/deployment-status@master
        with:
          token: "${{ github.token }}"
          state: "${{ needs.deploy-task-definition.result }}"
          deployment_id: ${{ needs.create-deployment.outputs.deployment_id }}

  # notify-deployment:
  #   runs-on: ubuntu-latest
  #   name: Notify deploy status on Slack
  #   if: ${{ always() }}
  #   needs: [create-deployment, deploy-task-definition]
  #   steps:
  #     - name: Report Status
  #       uses: ravsamhq/notify-slack-action@v1
  #       # if: always()
  #       with:
  #         status: ${{ needs.deploy-task-definition.result }}
  #         token: ${{ github.token }}
  #         notification_title: '[${{ inputs.environment }}] {workflow} has {status_message}'
  #         message_format: '{emoji} *[${{ inputs.environment }}] {workflow}* {status_message} in <{repo_url}|{repo}>'
  #         footer: 'Linked Repo <{repo_url}|{repo}> | <{run_url}|View Workflow Run> | <${{ needs.create-deployment.outputs.target_url }}|Check Service Status>'
  #         notify_when: 'success,failure,warnings,skipped'
  #         mention_groups: 'S022DRPB353'
  #         mention_groups_when: 'failure,warnings,skipped'
  #       env:
  #         SLACK_WEBHOOK_URL: ${{ inputs.environment == 'production' && secrets.production-slack-webhook || secrets.staging-slack-webhook }}