name: Deploy task definition to AWS ECS

on:
  workflow_call:
    inputs:
      aws-region:
        type: string
        required: false
        default: eu-central-1
      image-uri:
        type: string
        required: true
        description: The URI of the container image to insert into the ECS task definition
      image-tag:
        type: string
        required: false
        description: The container image tag to insert into the ECS task definition
      container-name:
        type: string
        required: false
        description: The name of the container defined in the containerDefinitions section of the ECS task definition
        default: app
      service-name:
        type: string
        required: false
        description: The name of the ECS service to deploy to.
      services:
        type: string
        required: false
        description: 'JSON list of services to be deployed. Example: { "include": [{"SERVICE": "rattle"}, {"SERVICE": "rattle-sidekiq"}] }'
        default: '{ "include": [] }'
      cluster:
        type: string
        required: true
        description: The name of the ECS service's cluster.
      environment:
        type: string
        required: true
        default: staging
        description: The stack environment of the ECS service.
      preview-task-definition:
        type: string
        required: false
        default: "false"
      skip-init-task:
        type: string
        required: false
        default: "false"
        description: Set true to skip init task.
      require-image-build:
        type: string
        required: false
        default: "false"
        description: Set true to build docker image.
      init-task-command:
        type: string
        required: false
        description: 'Init task command. Example: "rails db:migrate"'

    secrets:
      pat-github:
        required: true
      aws-access-key-id:
        required: true
      aws-secret-access-key:
        required: true
      staging-aws-deploy-role:
        required: true
      production-aws-deploy-role:
        required: true

      staging-ecs-template-bucket:
        required: true
        description: The S3 URI of the staging ECS template generated by Terraform.
      production-ecs-template-bucket:
        required: true
        description: The S3 URI of the production ECS template generated by Terraform.

      staging-slack-webhook:
        required: true
      production-slack-webhook:
        required: true

jobs:
  docker-build-push:
    name: Build docker image and push to ECR
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.export-sha.outputs.sha_short }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          ref: ${{ inputs.image-tag || github.sha }}
          token: ${{ secrets.pat-github }}
          submodules: "true"

      # Check if deployable to staging or prod?

      - name: Export short sha to outputs
        id: export-sha
        run: |
          echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1-node16
        with:
          aws-access-key-id: ${{ secrets.aws-access-key-id }}
          aws-secret-access-key: ${{ secrets.aws-secret-access-key }}
          aws-region: ${{ inputs.aws-region }}

      - name: Check if already built
        id: check-if-built
        run: |
          if [ '${{ inputs.require-image-build }}' == 'true' ]; then
            echo "image-built=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          image=$(aws ecr list-images --repository-name ${{ inputs.service-name }} --query "imageIds[?imageTag=='${{ steps.export-sha.outputs.sha_short }}'] | [0].imageTag")
          if [[ $image == null ]]; then
            echo "image-built=false" >> $GITHUB_OUTPUT
          else
            echo "::warning title=Skipping docker build::Image already exists on AWS ECR. Skipping image build."
            echo "image-built=true" >> $GITHUB_OUTPUT
          fi

      - name: Set up Docker Buildx
        if: ${{ steps.check-if-built.outputs.image-built == 'false' }}
        id: buildx
        uses: docker/setup-buildx-action@v2
        with:
          install: true

      - name: Cache Docker layers
        if: ${{ steps.check-if-built.outputs.image-built == 'false' }}
        uses: actions/cache@v3.3.1
        with:
          path: /tmp/.buildx-cache
          # Key is named differently to avoid collision
          key: ${{ runner.os }}-multi-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-multi-buildx

      - name: Build image
        if: ${{ steps.check-if-built.outputs.image-built == 'false' }}
        uses: docker/build-push-action@v3
        with:
          context: .
          builder: ${{ steps.buildx.outputs.name }}
          load: true
          push: false
          tags: ${{ inputs.image-uri }}:${{ steps.export-sha.outputs.sha_short }}
          cache-from: type=local,src=/tmp/.buildx-cache
          # Note the mode=max here
          # More: https://github.com/moby/buildkit#--export-cache-options
          # And: https://github.com/docker/buildx#--cache-tonametypetypekeyvalue
          cache-to: type=local,mode=max,dest=/tmp/.buildx-cache-new
          build-args: |
            COMMIT_ID=${{ steps.export-sha.outputs.sha_short }}

      - name: Login to Amazon ECR
        if: ${{ steps.check-if-built.outputs.image-built == 'false' }}
        uses: aws-actions/amazon-ecr-login@v1

      - name: Push docker image to ECR
        if: ${{ steps.check-if-built.outputs.image-built == 'false' }}
        run: |
          docker push ${{ inputs.image-uri }}:${{ steps.export-sha.outputs.sha_short }}

      - name: Move cache
        if: ${{ steps.check-if-built.outputs.image-built == 'false' }}
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

  create-deployment:
    name: Create Deployment
    runs-on: ubuntu-latest
    needs: [docker-build-push]
    outputs:
      deployment_id: ${{ steps.create-deployment.outputs.deployment_id }}
      target_url: ${{ steps.export-status-url.outputs.url }}
    steps:
      - name: Export service status URL
        id: export-status-url
        env:
          DOMAIN: ${{ inputs.environment == 'prod' && 'suitepad.systems' || 'suitepad.engineering' }}
        run: |
          echo "url=https://${{ inputs.service-name }}.${{ inputs.environment }}.${{ env.DOMAIN }}/status" >> $GITHUB_OUTPUT

      - uses: chrnorm/deployment-action@v2.0.5
        name: Create deployment
        id: create-deployment
        with:
          ref: ${{ needs.docker-build-push.outputs.image-tag }}
          token: ${{ github.token }}
          environment: ${{ inputs.environment }}
          environment-url: ${{ steps.export-status-url.outputs.url }}
          description: "[${{ inputs.service-name }}-${{ inputs.environment }}]"
          initial-status: in_progress

  deploy-task-definition:
    name: Deploy main service and run init task
    runs-on: ubuntu-latest
    needs: [create-deployment, docker-build-push]
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1-node16
        with:
          role-to-assume: ${{ inputs.environment == 'prod' && secrets.production-aws-deploy-role || secrets.staging-aws-deploy-role }}
          role-skip-session-tagging: true
          role-duration-seconds: 3600
          aws-access-key-id: ${{ secrets.aws-access-key-id }}
          aws-secret-access-key: ${{ secrets.aws-secret-access-key }}
          aws-region: ${{ inputs.aws-region }}

      - name: Fetch Task Definition and Network configs
        id: fetch-task-definition
        env:
          TASK_DEFINITION_FILE: ${{ inputs.environment == 'prod' && secrets.production-ecs-template-bucket || secrets.staging-ecs-template-bucket }}
        run: |
          aws s3 cp ${{ env.TASK_DEFINITION_FILE }}/${{ inputs.cluster }}-${{ inputs.service-name }}-${{ inputs.environment }} /tmp/task-definition-template.json
          aws s3 cp ${{ env.TASK_DEFINITION_FILE }}/${{ inputs.cluster }}-${{ inputs.service-name }}-${{ inputs.environment }}-network-config /tmp/network-config.json
          NETWORK_CONFIG=$(cat /tmp/network-config.json)
          echo "network-config=${NETWORK_CONFIG//'%'/'%25'}" >> $GITHUB_OUTPUT

      - name: Render ECS task definition
        id: render-app-container
        uses: aws-actions/amazon-ecs-render-task-definition@v1.1.3
        with:
          task-definition: /tmp/task-definition-template.json
          container-name: ${{ inputs.container-name }}
          image: ${{ inputs.image-uri }}:${{ needs.docker-build-push.outputs.image-tag }}

      - name: Preview ECS task definition
        if: ${{ inputs.preview-task-definition == 'true' }}
        run: |
          cat ${{ steps.render-app-container.outputs.task-definition }}

      - name: Deploy to Amazon ECS service
        uses: chiragrajk/amazon-ecs-deploy-task-definition@feature/enable-init-tasks
        with:
          task-definition: ${{ steps.render-app-container.outputs.task-definition }}
          service: ${{ inputs.service-name }}-${{ inputs.environment }}
          cluster: ${{ inputs.cluster }}
          wait-for-service-stability: true
          wait-for-minutes: 10
          force-new-deployment: true
          init-task-command: ${{ inputs.skip-init-task != 'true' && inputs.init-task-command || '' }}
          init-task-network-configuration: ${{ steps.fetch-task-definition.outputs.network-config }}
          started-by: GHA-${{ github.actor }}

  deploy-sidecars:
    name: Deploy supporting services
    runs-on: ubuntu-latest
    needs: [docker-build-push, deploy-task-definition]

    if: ${{ fromJson(inputs.services).include[0] }}
    concurrency: deploy-sidecar-${{ matrix.SERVICE }}
    strategy:
      fail-fast: true
      matrix: ${{ fromJson(inputs.services) }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1-node16
        with:
          role-to-assume: ${{ inputs.environment == 'prod' && secrets.production-aws-deploy-role || secrets.staging-aws-deploy-role }}
          role-skip-session-tagging: true
          role-duration-seconds: 3600
          aws-access-key-id: ${{ secrets.aws-access-key-id }}
          aws-secret-access-key: ${{ secrets.aws-secret-access-key }}
          aws-region: ${{ inputs.aws-region }}

      - name: Fetch Task Definition template from S3
        env:
          TASK_DEFINITION_FILE: ${{ inputs.environment == 'prod' && secrets.production-ecs-template-bucket || secrets.staging-ecs-template-bucket }}
        run: |
          aws s3 cp ${{ env.TASK_DEFINITION_FILE }}/${{ inputs.cluster }}-${{ matrix.SERVICE }}-${{ inputs.environment }} /tmp/task-definition-template.json

      - name: Render ECS task definition
        id: render-app-container
        uses: aws-actions/amazon-ecs-render-task-definition@v1.1.3
        with:
          task-definition: /tmp/task-definition-template.json
          container-name: ${{ inputs.container-name }}
          image: ${{ inputs.image-uri }}:${{ needs.docker-build-push.outputs.image-tag }}

      - name: Preview ECS task definition
        if: ${{ inputs.preview-task-definition == 'true' }}
        run: |
          cat ${{ steps.render-app-container.outputs.task-definition }}

      - name: Deploy to Amazon ECS service
        uses: chiragrajk/amazon-ecs-deploy-task-definition@feature/enable-init-tasks
        with:
          task-definition: ${{ steps.render-app-container.outputs.task-definition }}
          service: ${{ matrix.SERVICE }}-${{ inputs.environment }}
          cluster: ${{ inputs.cluster }}
          wait-for-service-stability: true
          wait-for-minutes: 10
          force-new-deployment: true
          started-by: GHA-${{ github.actor }}

  update-deployment-status:
    runs-on: ubuntu-latest
    name: Update deployment status
    if: ${{ always() }}
    needs: [create-deployment, deploy-task-definition, deploy-sidecars]
    steps:
      - name: Update deployment status
        uses: chrnorm/deployment-status@v2.0.1
        env:
          SUCCESS: ${{ needs.deploy-task-definition.result == 'success' && (needs.deploy-sidecars.result == 'skipped' || needs.deploy-sidecars.result == 'success') }}
        with:
          token: "${{ github.token }}"
          state: ${{ env.SUCCESS == 'true' && 'success' || 'failure' }}
          deployment-id: ${{ needs.create-deployment.outputs.deployment_id }}

  notify-slack:
    name: Notify deploy status on Slack
    runs-on: ubuntu-latest
    if: ${{ always() }}
    needs: [create-deployment, deploy-task-definition, deploy-sidecars]
    steps:
      - name: Report Status
        uses: ravsamhq/notify-slack-action@v2
        env:
          # SUCCESS: ${{ needs.deploy-sidecars.result == 'success' || needs.deploy-sidecars.result != 'skipped' || (fromJson(inputs.services).include[0] == null &&  needs.deploy-task-definition.result == 'success') || false }}
          # if everything succeeds main=success, sidecar!=skipped, sidecar=success
          # if sidecar fails       main=success, sidecar!=skipped, sidecar=failed
          # if main fails          main=fail,    sidecar!=skipped, ...

          SUCCESS: ${{ needs.deploy-task-definition.result == 'success' && (needs.deploy-sidecars.result == 'skipped' || needs.deploy-sidecars.result == 'success') }}
          SLACK_WEBHOOK_URL: ${{ inputs.environment == 'prod' && secrets.production-slack-webhook || secrets.staging-slack-webhook }}
        with:
          status: ${{ env.SUCCESS == 'true' && 'success' || 'failure' }}
          token: ${{ github.token }}
          notification_title: "[${{ inputs.environment }}] {workflow} has {status_message}"
          message_format: "{emoji} *[${{ inputs.environment }}] {workflow}* {status_message} in <{repo_url}|{repo}>"
          footer: "Linked Repo <{repo_url}|{repo}> | <{run_url}|View Workflow Run> | <${{ needs.create-deployment.outputs.target_url }}|Check Service Status>"
          notify_when: "success,failure,warnings"
          mention_groups: "S022DRPB353"
          mention_groups_when: "failure,warnings"
